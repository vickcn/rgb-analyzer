import React, { useState, useRef, useEffect, useCallback } from 'react';
import CameraCapture from './components/CameraCapture';
import RGBDisplay from './components/RGBDisplay';
import DetectionControls from './components/DetectionControls';
import HistoryPanel from './components/HistoryPanel';
import RGB3DVisualization from './components/RGB3DVisualization';
import { exportToExcel, exportImages } from './utils/exportUtils';
import './App.css';

export interface RGBData {
  r: number;
  g: number;
  b: number;
  hex: string;
  timestamp: number;
  x: number;
  y: number;
  h?: number; // HSV values (optional for backward compatibility)
  s?: number;
  v?: number;
}

export interface TimeIntervalRecord {
  id: string;
  startTime: number;
  endTime: number;
  records: RGBData[];
  annotatedImage?: string; // base64 encoded annotated image
  rawImage?: string; // base64 encoded raw image
}

function App() {
  const [isCameraActive, setIsCameraActive] = useState(false);
  const [currentRGB, setCurrentRGB] = useState<RGBData | null>(null);
  const [detectionHistory, setDetectionHistory] = useState<RGBData[]>([]);
  const [isRecording, setIsRecording] = useState(false);
  const [recordingData, setRecordingData] = useState<RGBData[]>([]);
  const [recordingInterval, setRecordingInterval] = useState<NodeJS.Timeout | null>(null);
  const [show3DVisualization, setShow3DVisualization] = useState(false);
  const [shouldFreezeCamera, setShouldFreezeCamera] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isCameraFullscreen, setIsCameraFullscreen] = useState(false);
  const canvasRef = useRef<HTMLCanvasElement>(null);
  const [detectionSettings, setDetectionSettings] = useState({
    edgeThreshold1: 50,
    edgeThreshold2: 150,
    minArea: 100,
    blurKernel: 5,
    enableEdgeDetection: true,
    enableColorDetection: true,
    enableDetailedLogs: false, // ÁîüÁî¢Áí∞Â¢ÉÈ†êË®≠ÈóúÈñâË©≥Á¥∞ log
    // Êñ∞Â¢ûÔºöROI ËàáÂÉèÁ¥†ÈÅéÊøæÈ†êË®≠
    edgeMarginPercent: 5,
    minEdgeMarginPx: 2,
    whiteThreshold: 240,
    blackThreshold: 10,
    minSaturation: 10,
    sampleStep: 2
  });

  const handleRGBDetected = useCallback((rgbData: RGBData) => {
    setCurrentRGB(rgbData);
    setDetectionHistory(prev => [rgbData, ...prev.slice(0, 49)]); // ‰øùÁïôÊúÄËøë50Á≠ÜË®òÈåÑ
  }, []);

  const clearHistory = () => {
    setDetectionHistory([]);
  };

  const clearOldHistory = (minutes: number = 10) => {
    const cutoffTime = Date.now() - minutes * 60 * 1000;
    setDetectionHistory(prev => prev.filter(item => item.timestamp > cutoffTime));
  };

  // Ë™øË©¶3DË¶ñË¶∫ÂåñÁãÄÊÖã
  useEffect(() => {
    console.log('üîç App.tsx - show3DVisualization:', show3DVisualization, 'recordingData.length:', recordingData.length);
    if (recordingData.length > 0) {
      console.log('üìä Á¨¨‰∏ÄÁ≠ÜÊï∏Êìö:', recordingData[0]);
    }
  }, [show3DVisualization, recordingData]);

  // ÊôÇÊÆµÂçÄÈñìÁ¥ÄÈåÑÂäüËÉΩ
  const startRecording = () => {
    console.log('‚è∫Ô∏è ÈñãÂßãÊôÇÊÆµÁ¥ÄÈåÑ');
    
    if (!isCameraActive) {
      alert('Ë´ãÂÖàÂïüÂãïÊîùÂΩ±Ê©ü');
      return;
    }

    if (!currentRGB) {
      alert('Ë´ãÁ¢∫‰øùÊúâRGBÊï∏ÊìöÂèØË®òÈåÑ');
      return;
    }

    setIsRecording(true);
    setRecordingData([]);
    
    // ‰ΩøÁî®Êú¨Âú∞ËÆäÊï∏ËøΩËπ§Ë®òÈåÑÁãÄÊÖãÔºåÈÅøÂÖçÁãÄÊÖãÊõ¥Êñ∞ÊôÇÂ∫èÂïèÈ°å
    let isRecordingLocal = true;
    let recordCount = 0; // Êú¨Âú∞Ë®àÊï∏Âô®
    
    // ÊØè0.5ÁßíË®òÈåÑ‰∏ÄÁ≠ÜÊï∏Êìö
    const interval = setInterval(() => {
      // Ê™¢Êü•ÊòØÂê¶ÈÇÑÂú®Ë®òÈåÑÁãÄÊÖã
      if (!isRecordingLocal) {
        clearInterval(interval);
        return;
      }
      
      // ‰ΩøÁî®ÊúÄÊñ∞ÁöÑ currentRGB Êï∏Êìö
      if (currentRGB) {
        // Â¢ûÂä†Êú¨Âú∞Ë®àÊï∏Âô®
        recordCount++;
        
        // Ê∑ªÂä†‰∏Ä‰∫õÈö®Ê©üËÆäÂåñ‰æÜÊ®°Êì¨ÁúüÂØ¶ÁöÑÈ°èËâ≤ËÆäÂåñ
        const variation = 2; // ÂÖÅË®± ¬±2 ÁöÑËÆäÂåñ
        const rVariation = Math.floor(Math.random() * (variation * 2 + 1)) - variation;
        const gVariation = Math.floor(Math.random() * (variation * 2 + 1)) - variation;
        const bVariation = Math.floor(Math.random() * (variation * 2 + 1)) - variation;
        
        // ÂâµÂª∫Êñ∞ÁöÑ RGB Êï∏ÊìöÔºå‰ΩøÁî®Áï∂ÂâçÊôÇÈñìÊà≥ÂíåËºïÂæÆËÆäÂåñ
        const newRGBData = {
          r: Math.max(0, Math.min(255, currentRGB.r + rVariation)),
          g: Math.max(0, Math.min(255, currentRGB.g + gVariation)),
          b: Math.max(0, Math.min(255, currentRGB.b + bVariation)),
          hex: '', // Â∞áÂú®‰∏ãÈù¢Ë®àÁÆó
          timestamp: Date.now(),
          x: currentRGB.x,
          y: currentRGB.y
        };
        
        // Ë®àÁÆóÊñ∞ÁöÑ hex ÂÄº
        newRGBData.hex = `#${newRGBData.r.toString(16).padStart(2, '0')}${newRGBData.g.toString(16).padStart(2, '0')}${newRGBData.b.toString(16).padStart(2, '0')}`;
        
        setRecordingData(prev => {
          const newData = [...prev, newRGBData];
          return newData;
        });
        
        // Ê™¢Êü•ÊòØÂê¶ÈÅîÂà∞ÊúÄÂ§ßË®òÈåÑÊï∏
        if (recordCount >= 10) {
          console.log('üîü ÈÅîÂà∞ÊúÄÂ§ßË®òÈåÑÊï∏ÔºåËá™ÂãïÂÅúÊ≠¢');
          isRecordingLocal = false; // ÂÅúÊ≠¢Êú¨Âú∞Ë®òÈåÑÁãÄÊÖã
          // Áõ¥Êé•Ë™øÁî® stopRecordingÔºå‰∏ç‰ΩøÁî® setTimeout
          stopRecording(recordCount);
        }
      }
    }, 500);

    setRecordingInterval(interval);
  };

  const stopRecording = (currentDataCount?: number) => {
    console.log('üõë ÂÅúÊ≠¢ÊôÇÊÆµÁ¥ÄÈåÑ');
    const actualDataCount = currentDataCount || recordingData.length;
    console.log('üìä Ë®òÈåÑÂà∞ÁöÑÊï∏ÊìöÁ≠ÜÊï∏:', actualDataCount);
    
    // Á´ãÂç≥Ê∏ÖÈô§ÈñìÈöîÂô®
    if (recordingInterval) {
      clearInterval(recordingInterval);
      setRecordingInterval(null);
      console.log('‚èπÔ∏è Ê∏ÖÈô§Á¥ÄÈåÑÈñìÈöîÂô®');
    }
    
    // Ë®≠ÁΩÆÁãÄÊÖã
    setIsRecording(false);
    
    // Â¶ÇÊûúÊúâË®òÈåÑÂà∞Ë∂ÖÈÅé1Á≠ÜÊï∏ÊìöÔºåÈ°ØÁ§∫3DË¶ñË¶∫Âåñ‰∏¶ÂÆöÊ†ºÊúÄÂæå‰∏ÄÁßí
    if (actualDataCount > 1) {
      console.log('üé® Ê∫ñÂÇôÈ°ØÁ§∫3DË¶ñË¶∫ÂåñÔºåÊï∏ÊìöÁ≠ÜÊï∏:', actualDataCount);
      console.log('  - Áï∂ÂâçÊîùÂΩ±Ê©üÂÖ®Ëû¢ÂπïÁãÄÊÖã:', isCameraFullscreen);
      console.log('  - 3DË¶ñË¶∫ÂåñÂ∞á‰ª•', isCameraFullscreen ? 'ÊµÆÂãïË¶ÜËìãÂ±§' : 'Ê≠£Â∏∏Ê®°Âºè', 'È°ØÁ§∫');
      
      // ‰ΩøÁî® setTimeout Á¢∫‰øù recordingData ÁãÄÊÖãÂ∑≤Êõ¥Êñ∞
      setTimeout(() => {
        setShow3DVisualization(true);
        console.log('‚úÖ 3DË¶ñË¶∫ÂåñÁãÄÊÖãÂ∑≤Ë®≠ÁΩÆÁÇ∫È°ØÁ§∫');
        console.log('  - show3DVisualization: true');
        console.log('  - recordingData.length:', recordingData.length);
        console.log('  - isCameraFullscreen:', isCameraFullscreen);
        console.log('  - È†êÊúüÈ°ØÁ§∫Ê®°Âºè:', isCameraFullscreen ? 'floating-overlay (ÊµÆÂãïÂà∞ÂÖ®Ëû¢Âπï‰πã‰∏ä)' : 'normal-mode (Ê≠£Â∏∏È°ØÁ§∫)');
        
        // ÂÆöÊ†ºÊúÄÂæå‰∏ÄÁßíÁöÑÁãÄÊ≥Å
        console.log('üé¨ ÂÆöÊ†ºÊúÄÂæå‰∏ÄÁßíÁöÑÁãÄÊ≥Å');
        setShouldFreezeCamera(true);
        
        // 3ÁßíÂæåËá™ÂãïËß£Èô§ÂÆöÊ†ºÔºàÂèØÈÅ∏Ôºâ
        setTimeout(() => {
          console.log('‚èØÔ∏è Ëá™ÂãïËß£Èô§ÂÆöÊ†º');
          setShouldFreezeCamera(false);
        }, 3000);
      }, 100); // Áµ¶ÁãÄÊÖãÊõ¥Êñ∞‰∏ÄÈªûÊôÇÈñì
    } else {
      console.log('‚ö†Ô∏è Ë®òÈåÑÊï∏Êìö‰∏çË∂≥ÔºåÁÑ°Ê≥ïÈ°ØÁ§∫3DË¶ñË¶∫Âåñ (ÈúÄË¶ÅË∂ÖÈÅé1Á≠Ü)');
    }
  };

  const handleExportChoice = (choice: 'none' | 'images' | 'xlsx' | 'both') => {
    console.log('üì§ Áî®Êà∂ÈÅ∏ÊìáÂåØÂá∫ÈÅ∏È†Ö:', choice);
    
    switch (choice) {
      case 'none':
        // Ê∏ÖÁ©∫Ë®òÊÜ∂È´î
        console.log('üóëÔ∏è Ê∏ÖÈô§Ë®òÈåÑÊï∏Êìö');
        setRecordingData([]);
        setShow3DVisualization(false);
        break;
      case 'images':
        // ÂåØÂá∫Á¥îÂúñ
        console.log('üñºÔ∏è ÂåØÂá∫ÂúñÁâá');
        handleExportImages();
        break;
      case 'xlsx':
        // ÂåØÂá∫xlsx
        console.log('üìä ÂåØÂá∫Excel');
        exportXLSX();
        break;
      case 'both':
        // ÂåØÂá∫Á¥îÂúñËàáxlsx
        console.log('üì¶ ÂåØÂá∫ÂÖ®ÈÉ®');
        handleExportImages();
        exportXLSX();
        break;
    }
  };

  const handleExportImages = async () => {
    try {
      if (canvasRef.current) {
        await exportImages(canvasRef.current, recordingData);
        alert(`ÊàêÂäüÂåØÂá∫ ${recordingData.length} Á≠ÜË®òÈåÑÁöÑÂúñÁâá`);
      } else {
        alert('ÁÑ°Ê≥ïÁç≤ÂèñÁï´Èù¢ÔºåË´ãÁ¢∫‰øùÊîùÂΩ±Ê©üÊ≠£Âú®ÈÅãË°å');
      }
    } catch (error) {
      console.error('ÂåØÂá∫ÂúñÁâáÂ§±Êïó:', error);
      alert('ÂåØÂá∫ÂúñÁâáÂ§±ÊïóÔºåË´ãÈáçË©¶');
    }
    setRecordingData([]);
    setShow3DVisualization(false);
  };

  const exportXLSX = () => {
    try {
      exportToExcel(recordingData);
      alert(`ÊàêÂäüÂåØÂá∫ ${recordingData.length} Á≠ÜË®òÈåÑÁöÑxlsxÊ™îÊ°à`);
    } catch (error) {
      console.error('ÂåØÂá∫xlsxÂ§±Êïó:', error);
      alert('ÂåØÂá∫xlsxÂ§±ÊïóÔºåË´ãÈáçË©¶');
    }
    setRecordingData([]);
    setShow3DVisualization(false);
  };

  // Ë®àÁÆóRGBÊï∏ÊìöÁöÑÁµ±Ë®àË≥áË®ä
  const calculateRGBStats = () => {
    if (recordingData.length === 0) return null;

    console.log('üìä Ë®àÁÆóÁµ±Ë®àË≥áË®äÔºåË®òÈåÑÊï∏Êìö:', recordingData);
    const avgR = recordingData.reduce((sum, item) => sum + item.r, 0) / recordingData.length;
    const avgG = recordingData.reduce((sum, item) => sum + item.g, 0) / recordingData.length;
    const avgB = recordingData.reduce((sum, item) => sum + item.b, 0) / recordingData.length;
    console.log('üìä Âπ≥ÂùáÂÄº:', { avgR, avgG, avgB });

    // Ë®àÁÆóÊ≠êÂºèÁ©∫ÈñìË∑ùÈõ¢ÂíåÊ®ôÊ∫ñÂ∑Æ
    const distances = recordingData.map(item => {
      const diffR = item.r - avgR;
      const diffG = item.g - avgG;
      const diffB = item.b - avgB;
      return Math.sqrt(diffR * diffR + diffG * diffG + diffB * diffB);
    });

    const avgDistance = distances.reduce((sum, dist) => sum + dist, 0) / distances.length;
    const variance = distances.reduce((sum, dist) => sum + (dist - avgDistance) * (dist - avgDistance), 0) / distances.length;
    const standardDeviation = Math.sqrt(variance);

    // Ë®àÁÆóÂêÑÈÄöÈÅìÁöÑÊ®ôÊ∫ñÂ∑Æ
    const rVariance = recordingData.reduce((sum, item) => sum + (item.r - avgR) * (item.r - avgR), 0) / recordingData.length;
    const gVariance = recordingData.reduce((sum, item) => sum + (item.g - avgG) * (item.g - avgG), 0) / recordingData.length;
    const bVariance = recordingData.reduce((sum, item) => sum + (item.b - avgB) * (item.b - avgB), 0) / recordingData.length;

    return {
      average: { r: Math.round(avgR), g: Math.round(avgG), b: Math.round(avgB) },
      averageDistance: Math.round(avgDistance * 100) / 100,
      standardDeviation: Math.round(standardDeviation * 100) / 100,
      channelStdDev: {
        r: Math.round(Math.sqrt(rVariance) * 100) / 100,
        g: Math.round(Math.sqrt(gVariance) * 100) / 100,
        b: Math.round(Math.sqrt(bVariance) * 100) / 100
      },
      minDistance: Math.round(Math.min(...distances) * 100) / 100,
      maxDistance: Math.round(Math.max(...distances) * 100) / 100
    };
  };

  // ËøΩËπ§3DË¶ñË¶∫ÂåñÁãÄÊÖãËÆäÂåñÔºàÂè™Âú®ÁãÄÊÖãÁúüÊ≠£ÊîπËÆäÊôÇË®òÈåÑÔºâ
  useEffect(() => {
    if (show3DVisualization) {
      console.log('üé® 3DË¶ñË¶∫ÂåñÂ∑≤È°ØÁ§∫ÔºåË®òÈåÑÊï∏ÊìöÁ≠ÜÊï∏:', recordingData.length);
    }
  }, [show3DVisualization, recordingData.length]);

  // ÊîùÂΩ±Ê©üÂÖ®Ëû¢ÂπïÁãÄÊÖãÂõûË™ø
  const handleCameraFullscreenChange = useCallback((isFullscreen: boolean) => {
    setIsCameraFullscreen(isFullscreen);
    console.log('üì∫ App.tsx - ÊîùÂΩ±Ê©üÂÖ®Ëû¢ÂπïÁãÄÊÖãËÆäÂåñ:', isFullscreen);
  }, []);

  // ÈóúÈñâ 3D Ë¶ñË¶∫ÂåñÂõûË™ø
  const handleClose3DVisualization = useCallback(() => {
    console.log('üîÑ App.tsx - ÈóúÈñâ 3D Ë¶ñË¶∫Âåñ');
    setShow3DVisualization(false);
  }, []);

  // Ë™øË©¶3DË¶ñË¶∫ÂåñÈ°ØÁ§∫Ê¢ù‰ª∂
  useEffect(() => {
    console.log('üîç 3DË¶ñË¶∫ÂåñÈ°ØÁ§∫Ê¢ù‰ª∂Ê™¢Êü•:');
    console.log('  - show3DVisualization:', show3DVisualization);
    console.log('  - recordingData.length:', recordingData.length);
    console.log('  - Ê¢ù‰ª∂ÁµêÊûú:', show3DVisualization && recordingData.length > 1);
    console.log('  - isCameraFullscreen (App state):', isCameraFullscreen);
    console.log('  - document.fullscreenElement (Browser API):', document.fullscreenElement);
    console.log('  - ÁãÄÊÖãÊòØÂê¶‰∏ÄËá¥:', isCameraFullscreen === !!document.fullscreenElement);
    
    // Ê™¢Êü• 3D Ë¶ñË¶∫ÂåñÊòØÂê¶ÊáâË©≤È°ØÁ§∫
    if (show3DVisualization && recordingData.length > 1) {
      console.log('üé® 3DË¶ñË¶∫ÂåñÊáâË©≤È°ØÁ§∫');
      console.log('  - È°ØÁ§∫Ê®°Âºè:', isCameraFullscreen ? 'ÊµÆÂãïË¶ÜËìãÂ±§ (floating-overlay)' : 'Ê≠£Â∏∏Ê®°Âºè (normal-mode)');
      
      if (isCameraFullscreen) {
        console.log('üì∫ ÊîùÂΩ±Ê©üÂÖ®Ëû¢ÂπïÊ®°Âºè - 3DË¶ñË¶∫ÂåñÊáâË©≤ÊµÆÂãïÂà∞ÂÖ®Ëû¢ÂπïÁï´Â∏É‰πã‰∏ä');
        console.log('  - CSS È°ûÂà•: floating-overlay');
        console.log('  - z-index: 9999 (ÊúÄÈ´òÂ±§Á¥ö)');
        console.log('  - ‰ΩçÁΩÆ: position: fixed, top: 0, left: 0');
        console.log('  - Â∞∫ÂØ∏: width: 100vw, height: 100vh');
      } else {
        console.log('üì± Ê≠£Â∏∏Ê®°Âºè - 3DË¶ñË¶∫ÂåñÊ≠£Â∏∏È°ØÁ§∫Âú®È†ÅÈù¢‰∏≠');
        console.log('  - CSS È°ûÂà•: normal-mode');
        console.log('  - ‰ΩçÁΩÆ: Ê≠£Â∏∏ÊñáÊ™îÊµÅ');
      }
    } else {
      console.log('‚ùå 3DË¶ñË¶∫Âåñ‰∏çÊáâË©≤È°ØÁ§∫');
      if (!show3DVisualization) console.log('  - ÂéüÂõ†: show3DVisualization = false');
      if (recordingData.length <= 1) console.log('  - ÂéüÂõ†: recordingData.length <= 1');
    }
  }, [show3DVisualization, recordingData.length, isCameraFullscreen]);

  // Ë®òÈåÑ 3D Ë¶ñË¶∫ÂåñÊ∏≤ÊüìÁãÄÊÖã
  useEffect(() => {
    if (show3DVisualization && recordingData.length > 1) {
      console.log('üé® 3DË¶ñË¶∫ÂåñÊ≠£Âú®Ê∏≤Êüì:', {
        show3DVisualization,
        recordingDataLength: recordingData.length,
        isCameraFullscreen,
        className: isCameraFullscreen ? 'floating-overlay' : 'normal-mode',
        shouldFloat: isCameraFullscreen,
        renderTime: new Date().toISOString()
      });
      
      if (isCameraFullscreen) {
        console.log('üì∫ 3DË¶ñË¶∫ÂåñÊáâË©≤ÊµÆÂãïÂà∞ÂÖ®Ëû¢ÂπïÁï´Â∏É‰πã‰∏ä');
        console.log('  - ÂÖßËÅØÊ®£ÂºèÂ∑≤ÊáâÁî®: position: fixed, zIndex: 9999');
        console.log('  - Ë¶ÜËìãÁØÑÂúç: 100vw √ó 100vh');
        console.log('  - ËÉåÊôØ: rgba(0, 0, 0, 0.95)');
        
        // Ê™¢Êü• DOM ÂÖÉÁ¥†ÊòØÂê¶ÁúüÁöÑÂ≠òÂú®
        setTimeout(() => {
          const visualizationElement = document.querySelector('.visualization-section.floating-overlay');
          if (visualizationElement) {
            const rect = visualizationElement.getBoundingClientRect();
            const computedStyle = window.getComputedStyle(visualizationElement);
            console.log('üîç DOM ÂÖÉÁ¥†Ê™¢Êü•:');
            console.log('  - ÂÖÉÁ¥†Â≠òÂú®:', !!visualizationElement);
            console.log('  - ‰ΩçÁΩÆ:', { x: rect.x, y: rect.y, width: rect.width, height: rect.height });
            console.log('  - Ê®£Âºè:', {
              position: computedStyle.position,
              zIndex: computedStyle.zIndex,
              display: computedStyle.display,
              visibility: computedStyle.visibility,
              opacity: computedStyle.opacity
            });
            console.log('  - ÊòØÂê¶ÂèØË¶ã:', rect.width > 0 && rect.height > 0);
          } else {
            console.log('‚ùå DOM ÂÖÉÁ¥†‰∏çÂ≠òÂú®: .visualization-section.floating-overlay');
          }
        }, 100);
      }
    }
  }, [show3DVisualization, recordingData.length, isCameraFullscreen]);

  // Áõ£ËÅΩÂÖ®Ëû¢ÂπïÁãÄÊÖãËÆäÂåñ
  useEffect(() => {
    const handleFullscreenChange = () => {
      setIsFullscreen(!!document.fullscreenElement);
    };

    document.addEventListener('fullscreenchange', handleFullscreenChange);
    document.addEventListener('webkitfullscreenchange', handleFullscreenChange);
    document.addEventListener('msfullscreenchange', handleFullscreenChange);

    return () => {
      document.removeEventListener('fullscreenchange', handleFullscreenChange);
      document.removeEventListener('webkitfullscreenchange', handleFullscreenChange);
      document.removeEventListener('msfullscreenchange', handleFullscreenChange);
    };
  }, []);

  return (
    <div className="app">
      <header className="app-header">
        <h1>üé® RGB Ëâ≤ÂÖâÊ™¢Ê∏¨Âô®</h1>
        <p>ÈÄèÈÅéÊâãÊ©üÊîùÂΩ±Ê©üÂç≥ÊôÇÊ™¢Ê∏¨RGBËâ≤ÂÖâÂÄº</p>
      </header>

      <main className="app-main">
        <div className="camera-section">
          <CameraCapture
            isActive={isCameraActive}
            onCameraToggle={setIsCameraActive}
            onRGBDetected={handleRGBDetected}
            detectionSettings={detectionSettings}
            isRecording={isRecording}
            onStartRecording={startRecording}
            onStopRecording={stopRecording}
            recordingData={recordingData}
            canvasRef={canvasRef}
            shouldFreeze={shouldFreezeCamera}
            onFullscreenChange={handleCameraFullscreenChange}
            show3DVisualization={show3DVisualization}
            onClose3DVisualization={handleClose3DVisualization}
          />
        </div>

        <div className="controls-section">
          <DetectionControls
            settings={detectionSettings}
            onSettingsChange={setDetectionSettings}
          />
        </div>

        <div className="display-section">
          <RGBDisplay
            currentRGB={currentRGB}
            isActive={isCameraActive}
          />
        </div>

            <div className="history-section">
              <HistoryPanel
                history={detectionHistory}
                onClear={clearHistory}
                onClearOld={clearOldHistory}
              />
            </div>
      </main>


      {/* 3D RGBË¶ñË¶∫Âåñ - Âè™Âú®ÊîùÂΩ±Ê©üÂÖ®Ëû¢ÂπïÊôÇÊµÆÂãïÈ°ØÁ§∫ */}
      {show3DVisualization && recordingData.length > 1 && (
        <div 
          className={`visualization-section ${isCameraFullscreen ? 'floating-overlay' : 'normal-mode'}`}
          style={{
            // Ê∑ªÂä†ÂÖßËÅØÊ®£Âºè‰ª•‰æøË™øË©¶
            ...(isCameraFullscreen && {
              position: 'absolute',
              top: 0,
              left: 0,
              width: '100vw',
              height: '100vh',
              zIndex: 99999,
              backgroundColor: 'rgba(255, 0, 0, 0.8)',
              border: '5px solid yellow',
              pointerEvents: 'auto'
            })
          }}
        >
          <div className="visualization-header">
            <h3>üé® RGB 3D Ë¶ñË¶∫ÂåñÂ†±Âëä</h3>
            <div className="export-buttons">
              <button 
                onClick={() => handleExportChoice('images')} 
                className="export-btn images-btn"
                title="ÂåØÂá∫ÂúñÁâáÔºàÂéüÂúñËàáÊ®ôË®ªÂúñÔºâ"
              >
                üñºÔ∏è ÂåØÂá∫ÂúñÁâá
              </button>
              <button 
                onClick={() => handleExportChoice('xlsx')} 
                className="export-btn xlsx-btn"
                title="ÂåØÂá∫ExcelË°®Ê†º"
              >
                üìä ÂåØÂá∫Excel
              </button>
              <button 
                onClick={() => handleExportChoice('both')} 
                className="export-btn both-btn"
                title="ÂåØÂá∫ÂúñÁâáËàáExcel"
              >
                üì¶ ÂåØÂá∫ÂÖ®ÈÉ®
              </button>
              <button 
                onClick={() => handleExportChoice('none')} 
                className="export-btn clear-btn"
                title="Ê∏ÖÈô§Êï∏Êìö"
              >
                üóëÔ∏è Ê∏ÖÈô§Êï∏Êìö
              </button>
            </div>
          </div>
          
          <RGB3DVisualization data={recordingData} isVisible={show3DVisualization} />
          
          {calculateRGBStats() && (
            <div className="rgb-stats">
              <h4>üìä RGB Á©∫ÈñìÂàÜÂ∏ÉÁµ±Ë®à</h4>
              <div className="stats-grid">
                <div className="stat-item">
                  <span className="stat-label">Âπ≥ÂùáÂÄº:</span>
                  <span className="stat-value">
                    RGB({calculateRGBStats()!.average.r}, {calculateRGBStats()!.average.g}, {calculateRGBStats()!.average.b})
                  </span>
                </div>
                <div className="stat-item">
                  <span className="stat-label">Âπ≥ÂùáÊ≠êÂºèË∑ùÈõ¢:</span>
                  <span className="stat-value">{calculateRGBStats()!.averageDistance}</span>
                </div>
                <div className="stat-item">
                  <span className="stat-label">Ê≠êÂºèÁ©∫ÈñìÊ®ôÊ∫ñÂ∑Æ:</span>
                  <span className="stat-value">{calculateRGBStats()!.standardDeviation}</span>
                </div>
                <div className="stat-item">
                  <span className="stat-label">Ë∑ùÈõ¢ÁØÑÂúç:</span>
                  <span className="stat-value">
                    {calculateRGBStats()!.minDistance} ~ {calculateRGBStats()!.maxDistance}
                  </span>
                </div>
                <div className="stat-item">
                  <span className="stat-label">ÂêÑÈÄöÈÅìÊ®ôÊ∫ñÂ∑Æ:</span>
                  <span className="stat-value">
                    R:{calculateRGBStats()!.channelStdDev.r} G:{calculateRGBStats()!.channelStdDev.g} B:{calculateRGBStats()!.channelStdDev.b}
                  </span>
                </div>
                <div className="stat-item">
                  <span className="stat-label">Ë®òÈåÑÈªûÊï∏:</span>
                  <span className="stat-value">{recordingData.length} ÂÄã</span>
                </div>
              </div>
            </div>
          )}
        </div>
      )}

      <footer className="app-footer">
        <p>‰ΩøÁî® OpenCV.js ÈÄ≤Ë°åÂç≥ÊôÇÂúñÂÉèËôïÁêÜ</p>
      </footer>
    </div>
  );
}

export default App;